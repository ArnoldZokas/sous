#!/bin/bash

# This script takes a list of files  and turns them into a golang string literals,
# effectively embedding files in the binary for easy distribution.

# Generated files are placed in the same directory as input files. The name of the
# generated file is the same as the input file, with any extension changed to *.go.
# This means that: you cannot have input files ending in ".go", and all files in a
# directory must have unique names when their extensions are stripped.
#
# The name of the variable defined in each file is the same as the input filename,
# with the extension stripped, and any dashes '-' transformed to underscores '_'.
#
# The package name for each file matches the containing directory name, as per
# standard go conventions.

log() { echo "$@" >&2; }
die() { log "$@"; exit 1; }
BIN="$0"
usage() { die "usage: $BIN <input-dir>..."; }
[ -z "$1" ] && usage
generate() {
	INPUT="$1"
	[ -z "$INPUT" ] && { log "Input file names cannot be empty."; return 1; }
	[ -f "$INPUT" ] || { log "Cannot find file $INPUT"; return 1; }
	FILE=$(basename $INPUT)
	DIR=$(dirname $INPUT)
	PACKAGE=$(basename $DIR)
	OUTFILE="${FILE%.*}"
	VAR="${OUTFILE//-/_}"
	OUT="$DIR/$OUTFILE.go"
	[ -d "$DIR" ] || die "Directory $DIR does not exist"
	FIRSTLINE="// File generated by command:"
	[ -f "$OUT" ] && {
		[ "$(head -n1 $OUT)" = "$FIRSTLINE" ] || \
			die "Cannot overwrite non-generated file $OUT, delete it manually to re-generate."
	}
	#log "Generating $INPUT -> $OUT"
	echo "$FIRSTLINE" > $OUT
	echo "//     $BIN $INPUT" >> $OUT
	echo "package $PACKAGE" >> $OUT
	echo "" >> $OUT
	echo "func init() {" >> $OUT
	printf "\tFiles[\"$FILE\"] = \`" >> $OUT
	# Just replace any backticks, all other chars are safe.
	sed 's/`/\\`/g' $INPUT >> $OUT
	echo "\`}" >> $OUT
	echo $OUT
	printf "package $PACKAGE\n\nvar Files = map[string]string{}" > "$DIR/file_map.go"
}
SUCCEEDED=0
FAILED=0
while [ ! -z "$1" ]; do
	if [ -d "$1" ]; then
		find "$1" -type f ! -name '*.go' | {
			while read F; do
				if generate "$F"; then ((SUCCEEDED++)); else ((FAILED++)); fi
			done
		}
	else
		echo "$1 is not a directory"
		if generate "$1"; then ((SUCCEEDED++)); else ((FAILED++)); fi
	fi
	shift
done
RESULT="$FAILED failed, $SUCCEEDED succeeded."
[ ! "$FAILED" = "0" ] && die "Failed: $RESULT"

